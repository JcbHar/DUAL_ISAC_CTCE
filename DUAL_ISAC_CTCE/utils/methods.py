# ================================================================
# File: methods.py
# Description: method utils  
#
# Author: Jacob Stephens
# Email: psyjs32@nottingham.ac.uk
# University: University of Nottingham
#
# Dependencies:
# - ray[rllib], mujoco, numpy, matplotlib, pandas
# - Custom modules: models/, wrappers/
#
# ================================================================


import os
import sys
import json
import random
import mujoco
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from mpl_toolkits.axes_grid1.inset_locator import inset_axes


def generate_snake_U_targets(env, n_targets=4, x_bounds=(-0.5, 0.5), z_bounds=(0.6, 0.75),
                             y_fixed=0.0, jitter=0.02, seed=None, spread_factor=1.25,
                             middle_spread_bump=0.04):
    """
    Generates a U-shaped pattern of target positions in the x-z plane, 
    with middle targets slightly pushed outwards from the center.

    Parameters:
        env (DualPandaParallelEnv): The environment instance to apply target positions to.
        n_targets (int): Number of target points to generate (default: 4).
        x_bounds (Tuple[float, float]): Min and max bounds for the x-axis (left to right).
        z_bounds (Tuple[float, float]): Min and max bounds for the z-axis (bottom to top curve).
        y_fixed (float): Constant y-value for all targets (default: 0.0).
        jitter (float): Random noise added to x-positions to avoid perfect symmetry (default: 0.02).
        seed (int or None): Random seed for reproducibility (default: None).
        spread_factor (float): Multiplier to expand or contract the spacing in x (default: 1.25).
        middle_spread_bump (float): Additional spread applied to middle targets (default: 0.05).

    Returns:
        Dict[str, Tuple[float, float, float]]: Dictionary mapping target names to (x, y, z) positions.
    """
    if seed is not None:
        random.seed(seed)
        np.random.seed(seed)

    target_names = [f"target{i}" for i in range(4, 4 + n_targets)]

    base_x_vals = np.linspace(x_bounds[0], x_bounds[1], n_targets)
    x_center = np.mean(base_x_vals)

    spread_x_vals = (base_x_vals - x_center) * spread_factor + x_center
    spread_x_vals += np.random.uniform(-jitter, jitter, size=n_targets)

    if n_targets >= 2:
        mid_left_idx = n_targets // 2 - 1
        mid_right_idx = n_targets // 2
        spread_x_vals[mid_left_idx] -= middle_spread_bump
        spread_x_vals[mid_right_idx] += middle_spread_bump

    mid_idx = (n_targets - 1) / 2
    curve = [((i - mid_idx) / mid_idx) ** 2 for i in range(n_targets)]
    z_min, z_max = z_bounds
    z_range = z_max - z_min
    z_vals = [z_min + c * z_range for c in curve]

    z_bump = 0.05
    if n_targets >= 2:
        center_indices = [n_targets // 2 - 1, n_targets // 2]
        for idx in center_indices:
            z_vals[idx] += z_bump

    positions = {}
    for name, x, z in zip(target_names, spread_x_vals, z_vals):
        env.change_target_pos(name, x, y_fixed, z)
        positions[name] = (x, y_fixed, z)

    return positions


def plot_training_rewards(progress_csv_path):
    """
    Plots the mean episode reward over training iterations from a Ray Tune progress.csv.

    Parameters:
        progress_csv_path (str): Path to the progress.csv generated by Ray Tune.
    """

    if not os.path.exists(progress_csv_path):
        print(f"ERROR: {progress_csv_path} does not exist.")
        return

    df = pd.read_csv(progress_csv_path)

    if "training_iteration" not in df or "episode_reward_mean" not in df:
        print("Error: Required columns not found in progress.csv")
        return

    iterations = df["training_iteration"]
    rewards = df["episode_reward_mean"]

    plt.figure(figsize=(10, 5))
    plt.plot(iterations, rewards, marker="o", linestyle="-", color="orange")
    plt.xlabel("Training Iteration")
    plt.ylabel("Mean Episode Reward")
    plt.title("Training Rewards Over Iterations")
    plt.grid()

    plots_dir = os.path.dirname(progress_csv_path)
    save_path = os.path.join(plots_dir, "training_rewards.png")
    plt.savefig(save_path)
    plt.show()


def plot_per_agent_rewards(result_json_path):
    """
    Parses a Ray Tune result JSON file and plots per-agent reward over training iterations.

    Parameters:
        result_json_path (str): Path to the JSON file containing Ray Tune training logs.

    Returns:
        pd.DataFrame: A DataFrame containing iterations and rewards for each agent.
    """

    iterations = []
    robot0_rewards = []
    robot1_rewards = []

    with open(result_json_path, "r") as f:
        for line in f:
            entry = json.loads(line)
            it = entry.get("training_iteration")
            metrics = entry.get("custom_metrics", {})

            r0 = metrics.get("robot_0_total_reward", {}).get("mean", None)
            r1 = metrics.get("robot_1_total_reward", {}).get("mean", None)

            if r0 is not None and r1 is not None:
                iterations.append(it)
                robot0_rewards.append(r0)
                robot1_rewards.append(r1)

    df = pd.DataFrame({
        "iteration": iterations,
        "robot_0": robot0_rewards,
        "robot_1": robot1_rewards,
    })

    plt.plot(df["iteration"], df["robot_0"], label="Robot 0")
    plt.plot(df["iteration"], df["robot_1"], label="Robot 1")
    plt.xlabel("Training Iteration")
    plt.ylabel("Reward")
    plt.title("Reward per Robot")
    plt.legend()
    plt.grid(True)
    plt.show()

    return df


def plot_smooth_training_rewards(progress_csv_path, window_size=10, show_ci=True):
    """
    Plots the smoothed mean episode reward over training iterations with 95% CI.

    Parameters:
        progress_csv_path (str): Path to Ray Tune's progress.csv
        window_size (int): Rolling window size for smoothing.
        show_ci (bool): Whether to plot the 95% confidence interval.
    """
    if not os.path.exists(progress_csv_path):
        print(f"ERROR: {progress_csv_path} does not exist.")
        return

    df = pd.read_csv(progress_csv_path)

    if "training_iteration" not in df or "episode_reward_mean" not in df:
        print("Error: Required columns not found in progress.csv")
        return

    iterations = df["training_iteration"]
    rewards = df["episode_reward_mean"]

    rolling_mean = rewards.rolling(window=window_size, min_periods=1).mean()

    if show_ci:
        stderr = rewards.rolling(window=window_size, min_periods=1).std() / np.sqrt(window_size)
        ci_upper = rolling_mean + 1.96 * stderr
        ci_lower = rolling_mean - 1.96 * stderr

    plt.figure(figsize=(12, 6))
    plt.plot(iterations, rolling_mean, label="Smoothed Reward", color="orange")

    if show_ci:
        plt.fill_between(iterations, ci_lower, ci_upper, color="orange", alpha=0.3, label="95% CI")

    plt.xlabel("Training Iteration")
    plt.ylabel("Mean Episode Reward")
    plt.title("Training Rewards Over Iterations (Smoothed)")
    plt.grid()
    plt.legend()

    plots_dir = os.path.dirname(progress_csv_path)
    save_path = os.path.join(plots_dir, "training_rewards_smoothed.png")
    plt.savefig(save_path)
    plt.show()


def force_print_to_terminal():
    """
    Restores the standard output stream to the original system terminal.
    """
    sys.stdout = sys.__stdout__


def plot_multiple_training_rewards(csv_paths, labels, window_size=10, show_ci=True):
    """
    Plot smoothed training rewards for multiple experiments with 95% CI.

    Parameters:
        csv_paths (list): List of paths to `progress.csv` files.
        labels (list): Labels for each plot.
        window_size (int): Rolling window size for smoothing.
        show_ci (bool): Show 95% confidence interval.
    """
    plt.figure(figsize=(14, 7))

    for i, path in enumerate(csv_paths):
        if not os.path.exists(path):
            print(f"Path not found: {path}")
            continue

        df = pd.read_csv(path)
        if "training_iteration" not in df or "episode_reward_mean" not in df:
            print(f"Missing required columns in: {path}")
            continue

        iterations = df["training_iteration"]
        rewards = df["episode_reward_mean"]
        rolling_mean = rewards.rolling(window=window_size, min_periods=1).mean()
        color = f"C{i}"

        if show_ci:
            stderr = rewards.rolling(window=window_size, min_periods=1).std() / np.sqrt(window_size)
            ci_upper = rolling_mean + 1.96 * stderr
            ci_lower = rolling_mean - 1.96 * stderr
            plt.fill_between(iterations, ci_lower, ci_upper, alpha=0.15, color=color)

        plt.plot(iterations, rolling_mean, linewidth=2, label=labels[i], color=color)

    plt.xlabel("Training Iteration", fontsize=12)
    plt.ylabel("Mean Episode Reward", fontsize=12)
    plt.title("MPE Environments Tested Using ISAC CTCE", fontsize=14, weight="bold")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()